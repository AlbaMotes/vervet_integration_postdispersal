---
title: "Proximity Network Analysis"
author: "Alba Motes Rodrigo"
date: "2025-09-10"
output: 
  html_document:
    toc: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
    toc_depth: 3
    theme: flatly
    highlight: tango
    code_folding: show
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  error = FALSE,
  fig.width = 10,
  fig.height = 6
)
```

<style>
h1 {
  font-size: 32px;
  font-weight: bold;
}
h2 {
  font-size: 26px;
  font-weight: bold;
}
h3 {
  font-size: 22px;
  font-weight: bold;
}
</style>

# Load Packages and Data

```{r}
library(dplyr)
library(tidyr)
library(igraph)
library(purrr)

scans<-read.csv("/Users/alba/Library/Mobile Documents/com~apple~CloudDocs/Postdoc_UNIL/Diffusion_vervets/IVP_data/scans/scanswithid_ivp_1and2m.csv")
potential_immig<-read.csv("/Users/alba/Library/Mobile Documents/com~apple~CloudDocs/Postdoc_UNIL/Pooja_chapter_matrank/Data/All_potential_immigrants.csv")
```

# Explore Distance Data

```{r}
distance_year_table <- scans %>%
  filter(!is.na(distances_filled) & distances_filled != "") %>%
  # Split the semicolon-separated distances
  separate_rows(distances_filled, sep = ";") %>%
  # Clean up whitespace
  mutate(distance = trimws(distances_filled)) %>%
  # Group by year and individual distance
  group_by(year, distance) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(year, distance)

print(distance_year_table)

distance_pivot <- distance_year_table %>%
  pivot_wider(names_from = year, values_from = count, values_fill = 0) %>%
  arrange(distance)

print(distance_pivot)
```

# Prepare Scan Data

## Standardize Group Names and Individual IDs

```{r}
#change group names
group_abbreviations <- c("Baie Dankie" = "BD", "Noha" = "NH", "Ankhase" = "AK", 
                        "Kubu" = "KB", "Lemon Tree" = "LT", "Crossing"="CR", "IFamily"="IF")

# Create a new column with abbreviate group names
scans <- scans %>%
mutate(
    group_Abbreviation = group_abbreviations[group])  # Abbreviate group names

scans <- scans %>% 
  mutate(idindividual1 = tolower(idindividual1), 
         ind1m = tolower(ind1m), 
         ind2m = tolower(ind2m), 
         nnadult = tolower(nnadult), 
         nnjuvenile = tolower(nnjuvenile))
```

# Extract Proximity Interactions

## Scan Selection Logic

**Before 2022:**

1. If `ind1m` is filled → use it and STOP
2. If `ind1m` empty → check if `distancenna = "1m"` OR `distancennj = "1m"`
   - If `distancenna = "1m"` → use `nnadult`
   - If `distancennj = "1m"` → use `nnjuvenile`
3. Only if ALL three are empty (no `ind1m`, `distancenna ≠ "1m"`, `distancennj ≠ "1m"`):
   - Check `indarmlength`
   - Then check `distancenna = "Arm length"` OR `distancennj = "Arm length"`

**From 2022 onwards:**

Same hierarchy but flipped to prioritize Arm length first:

1. If `indarmlength` is filled → use it and STOP
2. If `indarmlength` empty → check if `distancenna = "Arm length"` OR `distancennj = "Arm length"`
3. Only if all Arm length sources are empty → check `ind1m` and 1m distances

**Notes:**

- The function uses as default for the end date of the metrics calculation the date the elo rating is calculated
- It can be adapted to include all data collected in the new group by specifying `end_date_col = "LastSeen1"`
- If you want both a calculation with the male-male rank and the male-female-rank, run it twice

## Extract Male Scan Interactions

```{r}
extract_male_scan_interactions <- function(scans, potential_immig, end_date_col = "elo_rating_date_one_year_all") {
  # Create an empty list to store results for each male
  scan_list <- list()
  
  # Validate end_date_col parameter
  if (!end_date_col %in% names(potential_immig)) {
    stop(paste("Column", end_date_col, "not found in potential_immig dataset"))
  }
  
  # Process each male in the potential_immig dataset
  for (i in 1:nrow(potential_immig)) {
    male_code <- potential_immig$Code[i]
    scan_list[[male_code]] <- data.frame()
    group_name <- potential_immig$ImmigrationGp1[i]
    start_date <- potential_immig$DateImmigration1[i]
    end_date <- potential_immig[[end_date_col]][i]  # Use specified column
    
    # Skip if any required data is missing
    if (is.na(male_code) || is.na(group_name) || is.na(start_date) || is.na(end_date)) {
      next
    }
    
    # Ensure dates are in Date format
    start_date <- as.Date(start_date)
    end_date <- as.Date(end_date)
    
    # Convert scan date column to Date format if it's character
    scans$date <- as.Date(scans$date)
    
    # Filter scan data for the specific group and time period
    group_data <- scans[
      scans$group_Abbreviation == group_name &
        !is.na(scans$date) &
        scans$date >= start_date &
        scans$date <= end_date,
    ]
    
    # Skip if no data found
    if (nrow(group_data) == 0) {
  message(paste("Male", male_code, "has no scan data - keeping with empty data"))
  next
}
    
    # Add year column for temporal logic
    group_data$year <- as.numeric(format(group_data$date, "%Y"))
    
    # Apply the correct hierarchy for proximity data
    proximity_data <- list()
    
    # Split data by year
    data_before_2022 <- group_data %>% filter(year < 2022)
    data_from_2022 <- group_data %>% filter(year >= 2022)
    
    # BEFORE 2022: 1m priority hierarchy
    if (nrow(data_before_2022) > 0) {
      processed_scans <- c()
      
      # 1. Check ind1m first
      if (any(!is.na(data_before_2022$ind1m) & data_before_2022$ind1m != "")) {
        ind1m_data <- data_before_2022 %>%
          filter(!is.na(ind1m) & ind1m != "") %>%
          separate_rows(ind1m, sep = ";") %>%
          mutate(interaction_partner = trimws(ind1m)) %>%
          filter(interaction_partner != "") %>%
          select(-ind1m)
        proximity_data <- append(proximity_data, list(ind1m_data))
        processed_scans <- unique(ind1m_data$scan_id)
      }
      
      # 2. Check distance-based 1m for remaining scans
      remaining_data <- data_before_2022 %>% filter(!scan_id %in% processed_scans)
      if (nrow(remaining_data) > 0) {
        distance_1m_data <- list()
        
        # nnadult when distancenna = 1m
        nnadult_1m <- remaining_data %>%
          filter(!is.na(distancenna) & distancenna == "1m" &
                 !is.na(nnadult) & nnadult != "") %>%
          separate_rows(nnadult, sep = ";") %>%
          mutate(interaction_partner = trimws(tolower(nnadult))) %>%
          filter(interaction_partner != "") %>%
          select(-nnadult)
        if (nrow(nnadult_1m) > 0) {
          distance_1m_data <- append(distance_1m_data, list(nnadult_1m))
        }
        
        # nnjuvenile when distancennj = 1m
        nnjuvenile_1m <- remaining_data %>%
          filter(!is.na(distancennj) & distancennj == "1m" &
                 !is.na(nnjuvenile) & nnjuvenile != "") %>%
          separate_rows(nnjuvenile, sep = ";") %>%
          mutate(interaction_partner = trimws(tolower(nnjuvenile))) %>%
          filter(interaction_partner != "") %>%
          select(-nnjuvenile)
        if (nrow(nnjuvenile_1m) > 0) {
          distance_1m_data <- append(distance_1m_data, list(nnjuvenile_1m))
        }
        
        if (length(distance_1m_data) > 0) {
          combined_1m <- bind_rows(distance_1m_data)
          proximity_data <- append(proximity_data, list(combined_1m))
          processed_scans <- c(processed_scans, unique(combined_1m$scan_id))
        }
      }
      
      # 3. Check indarmlength and Arm length distances for final remaining scans
      final_remaining <- data_before_2022 %>% filter(!scan_id %in% processed_scans)
      if (nrow(final_remaining) > 0) {
        arm_processed_scans <- c()
        
        # Check indarmlength
        if (any(!is.na(final_remaining$indarmlength) & final_remaining$indarmlength != "")) {
          indarmlength_data <- final_remaining %>%
            filter(!is.na(indarmlength) & indarmlength != "") %>%
            separate_rows(indarmlength, sep = ";") %>%
            mutate(interaction_partner = trimws(indarmlength)) %>%
            filter(interaction_partner != "") %>%
            select(-indarmlength)
          proximity_data <- append(proximity_data, list(indarmlength_data))
          arm_processed_scans <- unique(indarmlength_data$scan_id)
        }
        
        # Check Arm length distances for remaining scans
        arm_remaining <- final_remaining %>% filter(!scan_id %in% arm_processed_scans)
        if (nrow(arm_remaining) > 0) {
          distance_arm_data <- list()
          
          # nnadult when distancenna = Arm length
          nnadult_arm <- arm_remaining %>%
            filter(!is.na(distancenna) & distancenna == "Arm length" &
                   !is.na(nnadult) & nnadult != "") %>%
            separate_rows(nnadult, sep = ";") %>%
            mutate(interaction_partner = trimws(tolower(nnadult))) %>%
            filter(interaction_partner != "") %>%
            select(-nnadult)
          if (nrow(nnadult_arm) > 0) {
            distance_arm_data <- append(distance_arm_data, list(nnadult_arm))
          }
          
          # nnjuvenile when distancennj = Arm length
          nnjuvenile_arm <- arm_remaining %>%
            filter(!is.na(distancennj) & distancennj == "Arm length" &
                   !is.na(nnjuvenile) & nnjuvenile != "") %>%
            separate_rows(nnjuvenile, sep = ";") %>%
            mutate(interaction_partner = trimws(tolower(nnjuvenile))) %>%
            filter(interaction_partner != "") %>%
            select(-nnjuvenile)
          if (nrow(nnjuvenile_arm) > 0) {
            distance_arm_data <- append(distance_arm_data, list(nnjuvenile_arm))
          }
          
          if (length(distance_arm_data) > 0) {
            combined_arm <- bind_rows(distance_arm_data)
            proximity_data <- append(proximity_data, list(combined_arm))
          }
        }
      }
    }
    
    # FROM 2022 ONWARDS: Arm length priority hierarchy
    if (nrow(data_from_2022) > 0) {
      processed_scans_2022 <- c()
      
      # 1. Check indarmlength first
      if (any(!is.na(data_from_2022$indarmlength) & data_from_2022$indarmlength != "")) {
        indarmlength_data_2022 <- data_from_2022 %>%
          filter(!is.na(indarmlength) & indarmlength != "") %>%
          separate_rows(indarmlength, sep = ";") %>%
          mutate(interaction_partner = trimws(indarmlength)) %>%
          filter(interaction_partner != "") %>%
          select(-indarmlength)
        proximity_data <- append(proximity_data, list(indarmlength_data_2022))
        processed_scans_2022 <- unique(indarmlength_data_2022$scan_id)
      }
      
      # 2. Check distance-based Arm length for remaining scans
      remaining_data_2022 <- data_from_2022 %>% filter(!scan_id %in% processed_scans_2022)
      if (nrow(remaining_data_2022) > 0) {
        distance_arm_data_2022 <- list()
        
        # nnadult when distancenna = Arm length
        nnadult_arm_2022 <- remaining_data_2022 %>%
          filter(!is.na(distancenna) & distancenna == "Arm length" &
                 !is.na(nnadult) & nnadult != "") %>%
          separate_rows(nnadult, sep = ";") %>%
          mutate(interaction_partner = trimws(tolower(nnadult))) %>%
          filter(interaction_partner != "") %>%
          select(-nnadult)
        if (nrow(nnadult_arm_2022) > 0) {
          distance_arm_data_2022 <- append(distance_arm_data_2022, list(nnadult_arm_2022))
        }
        
        # nnjuvenile when distancennj = Arm length
        nnjuvenile_arm_2022 <- remaining_data_2022 %>%
          filter(!is.na(distancennj) & distancennj == "Arm length" &
                 !is.na(nnjuvenile) & nnjuvenile != "") %>%
          separate_rows(nnjuvenile, sep = ";") %>%
          mutate(interaction_partner = trimws(tolower(nnjuvenile))) %>%
          filter(interaction_partner != "") %>%
          select(-nnjuvenile)
        if (nrow(nnjuvenile_arm_2022) > 0) {
          distance_arm_data_2022 <- append(distance_arm_data_2022, list(nnjuvenile_arm_2022))
        }
        
        if (length(distance_arm_data_2022) > 0) {
          combined_arm_2022 <- bind_rows(distance_arm_data_2022)
          proximity_data <- append(proximity_data, list(combined_arm_2022))
          processed_scans_2022 <- c(processed_scans_2022, unique(combined_arm_2022$scan_id))
        }
      }
      
      # 3. Check ind1m and 1m distances for final remaining scans
      final_remaining_2022 <- data_from_2022 %>% filter(!scan_id %in% processed_scans_2022)
      if (nrow(final_remaining_2022) > 0) {
        one_m_processed_scans <- c()
        
        # Check ind1m
        if (any(!is.na(final_remaining_2022$ind1m) & final_remaining_2022$ind1m != "")) {
          ind1m_data_2022 <- final_remaining_2022 %>%
            filter(!is.na(ind1m) & ind1m != "") %>%
            separate_rows(ind1m, sep = ";") %>%
            mutate(interaction_partner = trimws(ind1m)) %>%
            filter(interaction_partner != "") %>%
            select(-ind1m)
          proximity_data <- append(proximity_data, list(ind1m_data_2022))
          one_m_processed_scans <- unique(ind1m_data_2022$scan_id)
        }
        
        # Check 1m distances for remaining scans
        one_m_remaining <- final_remaining_2022 %>% filter(!scan_id %in% one_m_processed_scans)
        if (nrow(one_m_remaining) > 0) {
          distance_1m_data_2022 <- list()
          
          # nnadult when distancenna = 1m
          nnadult_1m_2022 <- one_m_remaining %>%
            filter(!is.na(distancenna) & distancenna == "1m" &
                   !is.na(nnadult) & nnadult != "") %>%
            separate_rows(nnadult, sep = ";") %>%
            mutate(interaction_partner = trimws(tolower(nnadult))) %>%
            filter(interaction_partner != "") %>%
            select(-nnadult)
          if (nrow(nnadult_1m_2022) > 0) {
            distance_1m_data_2022 <- append(distance_1m_data_2022, list(nnadult_1m_2022))
          }
          
          # nnjuvenile when distancennj = 1m
          nnjuvenile_1m_2022 <- one_m_remaining %>%
            filter(!is.na(distancennj) & distancennj == "1m" &
                   !is.na(nnjuvenile) & nnjuvenile != "") %>%
            separate_rows(nnjuvenile, sep = ";") %>%
            mutate(interaction_partner = trimws(tolower(nnjuvenile))) %>%
            filter(interaction_partner != "") %>%
            select(-nnjuvenile)
          if (nrow(nnjuvenile_1m_2022) > 0) {
            distance_1m_data_2022 <- append(distance_1m_data_2022, list(nnjuvenile_1m_2022))
          }
          
          if (length(distance_1m_data_2022) > 0) {
            combined_1m_2022 <- bind_rows(distance_1m_data_2022)
            proximity_data <- append(proximity_data, list(combined_1m_2022))
          }
        }
      }
    }
    
    # Combine all proximity data
    if (length(proximity_data) > 0) {
      group_data_final <- bind_rows(proximity_data) %>%
        distinct()  # Remove any duplicates
      scan_list[[male_code]] <- group_data_final
    } else {
      message(paste("Male", male_code, "has no proximity data - keeping with empty data"))
      # scan_list[[male_code]] already initialized as empty dataframe at the start
    }
  }
  
  return(scan_list)
}

scan_list <- extract_male_scan_interactions(scans, potential_immig)
```

# Calculate Network Metrics

```{r}
library(dplyr)
library(igraph)

# Function to calculate network metrics for immigrant males using scan_list data
calculate_proximity_network_metrics <- function(scan_list, potential_immig) {
  # Initialize results dataframe
  network_metrics <- data.frame(
    immigrant_code = character(),
    group = character(),
    degree = numeric(),
    strength = numeric(),
    strength_assoc = numeric(),
    eigenvector_centrality = numeric(),
    total_scans = numeric(),
    total_dyads = numeric(),
    stringsAsFactors = FALSE
  )
  
  # Process each immigrant male
  for (immigrant_code in names(scan_list)) {
    # Get the scan data for this immigrant (already processed with interaction_partner column)
    scan_data <- scan_list[[immigrant_code]]
    
    if (is.null(scan_data) || nrow(scan_data) == 0) {
  message(paste("No scan data for immigrant", immigrant_code, "- storing with NA metrics"))
  immigrant_info <- potential_immig[potential_immig$Code == immigrant_code, ]
  group_name <- if(nrow(immigrant_info) > 0) immigrant_info$ImmigrationGp1[1] else NA
  
  network_metrics <- rbind(network_metrics, data.frame(
    immigrant_code = immigrant_code,
    group = group_name,
    degree = NA,
    strength = NA,
    strength_assoc = NA,
    eigenvector_centrality = NA,
    total_scans = NA,
    total_dyads = NA,
    stringsAsFactors = FALSE
  ))
  next
}
    
    # Get immigrant info
    immigrant_info <- potential_immig[potential_immig$Code == immigrant_code, ]
    if (nrow(immigrant_info) == 0) {
      warning(paste("No immigrant info found for", immigrant_code))
      next
    }
    
    group_name <- immigrant_info$ImmigrationGp1[1]
    
    # Calculate individual scan counts for ALL individuals (both idindividual1 and interaction_partner)
    individual_scan_counts <- scan_data %>%
      filter(!is.na(idindividual1) & idindividual1 != "") %>%
      pivot_longer(cols = c(idindividual1, interaction_partner),
                   values_to = "individual",
                   names_to = "role") %>%
      filter(!is.na(individual) & individual != "") %>%
      group_by(individual) %>%
      summarise(scans_sampled = n_distinct(scan_id), .groups = 'drop')
    
    # Create standardized dyads (always put alphabetically smaller ID first)
    scan_dyads <- scan_data %>%
      filter(!is.na(interaction_partner) & interaction_partner != "" &
             !is.na(idindividual1) & idindividual1 != "") %>%
      mutate(
        individual_a = pmin(idindividual1, interaction_partner),
        individual_b = pmax(idindividual1, interaction_partner)
      ) %>%
      filter(individual_a != individual_b)  # Remove self-loops
    
    cat("Valid dyads for immigrant", immigrant_code, ":", nrow(scan_dyads), "\n")
    
    if (nrow(scan_dyads) == 0) {
      warning(paste("No valid dyads found for immigrant", immigrant_code))
      next
    }
    
    # Create edgelist by counting co-occurrences per scan (following past method)
    edgelist <- scan_dyads %>%
      group_by(individual_a, individual_b) %>%
      summarise(
        co_occurrence_scans = n_distinct(scan_id),  # Number of scans they appeared together
        total_observations = n(),                    # Total observations (for reference)
        .groups = 'drop'
      ) %>%
      # Add individual scan counts
      left_join(
        individual_scan_counts %>% select(individual, scans_individual_a = scans_sampled),
        by = c("individual_a" = "individual")
      ) %>%
      left_join(
        individual_scan_counts %>% select(individual, scans_individual_b = scans_sampled),
        by = c("individual_b" = "individual")
      ) %>%
      # Calculate association metrics (same as past method)
      mutate(
        total_dyad_scans = scans_individual_a + scans_individual_b,
        association_rate = co_occurrence_scans / total_dyad_scans
      ) %>%
      # Remove dyads where one individual has no scan count
      filter(!is.na(scans_individual_a) & !is.na(scans_individual_b))
    
    if (nrow(edgelist) == 0) {
      warning(paste("No valid edgelist created for immigrant", immigrant_code))
      next
    }
    
    # Create igraph object with both edge weights
    g <- graph_from_data_frame(
      d = edgelist[, c("individual_a", "individual_b", "co_occurrence_scans", "association_rate")],
      directed = FALSE
    )

    # Check if immigrant is in the network
if (!immigrant_code %in% V(g)$name) {
  warning(paste("Immigrant", immigrant_code, "not found in network - storing with NA metrics"))
  
  network_metrics <- rbind(network_metrics, data.frame(
    immigrant_code = immigrant_code,
    group = group_name,
    degree = NA,
    strength = NA,
    strength_assoc = NA,
    eigenvector_centrality = NA,
    total_scans = NA,
    total_dyads = nrow(edgelist),
    stringsAsFactors = FALSE
  ))
  next
}
    
    # Calculate network metrics for the immigrant
    degree_val <- igraph::degree(g,  immigrant_code)
    strength_val <- strength(g, v = immigrant_code, weights = E(g)$co_occurrence_scans)  # Pure strength
    strength_assoc_val <- strength(g, v = immigrant_code, weights = E(g)$association_rate)  # Association rate strength
    
    # Calculate eigenvector centrality (handle potential errors)
    eigen_cent <- tryCatch({
      eigen_centrality(g, weights = E(g)$association_rate)$vector[immigrant_code]
    }, error = function(e) {
      warning(paste("Could not calculate eigenvector centrality for", immigrant_code, ":", e$message))
      NA
    })
 
    # Get total scans for the immigrant
    immigrant_scans <- individual_scan_counts$scans_sampled[individual_scan_counts$individual == immigrant_code]
    if (length(immigrant_scans) == 0) immigrant_scans <- NA
    
    # Store results
    network_metrics <- rbind(network_metrics, data.frame(
      immigrant_code = immigrant_code,
      group = group_name,
      degree = degree_val,
      strength = strength_val,              # Sum of co_occurrence_scans
      strength_assoc = strength_assoc_val,  # Sum of association rates
      eigenvector_centrality = ifelse(is.null(eigen_cent), NA, eigen_cent),
      total_scans = immigrant_scans,
      total_dyads = nrow(edgelist),
      stringsAsFactors = FALSE
    ))
  }
  
  return(network_metrics)
}

# Usage:
network_metrics <- calculate_proximity_network_metrics(scan_list, potential_immig)
```

# Save Results

```{r}
network_metrics_prox_all <- network_metrics %>%
  left_join(potential_immig, 
            by = c("immigrant_code" = "Code"))

write.csv(network_metrics_prox_all, "/Users/alba/Library/Mobile Documents/com~apple~CloudDocs/Postdoc_UNIL/Pooja_chapter_matrank/Data/network_metrics_prox_male_female.csv")
```

---

**Analysis completed:** `r Sys.Date()`
